package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"chain/protocol/vm"
	"chain/protocol/vmutil"
)

var (
	flagDebug = flag.Bool("debug", false, "run in debug mode")
	flagGo    = flag.Bool("go", false, "generate Go code")
)

func main() {
	flag.Parse()

	var (
		in                      []byte
		err                     error
		inFilename, outFilename string
		outFile                 *os.File
	)

	if a := flag.Args(); len(a) > 0 {
		inFilename = a[0]
		in, err = ioutil.ReadFile(inFilename)
		if *flagGo {
			outFilename = strings.TrimSuffix(inFilename, ".p2c")
			outFilename += ".go"
		}
	} else {
		if *flagGo {
			panic(fmt.Errorf("Cannot use stdin with -go"))
		}
		in, err = ioutil.ReadAll(os.Stdin)
	}
	if err != nil {
		panic(err)
	}
	if outFilename != "" {
		outFile, err = os.OpenFile(outFilename, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0644)
		if err != nil {
			panic(err)
		}
		defer outFile.Close()

		fmt.Fprintf(outFile, "// Generated by \"p2cc -go %s\"\n\n", inFilename)

		absIn, err := filepath.Abs(inFilename)
		if err != nil {
			panic(err)
		}
		fmt.Fprintf(outFile, "package %s\n\n", filepath.Base(filepath.Dir(absIn)))
		fmt.Fprint(outFile, "import (\n\t\"chain/protocol/bc\"\n\t\"chain/protocol/vm\"\n\t\"chain/protocol/vmutil\"\n)\n")
	}

	contracts, err := parse(in)
	if err != nil {
		panic(err)
	}

	type contractPair struct {
		parsed     *contract
		translated *translation
	}

	contractPairs := make([]contractPair, 0, len(contracts))

	for _, contract := range contracts {
		res, err := translate(contract, contracts)
		if err != nil {
			panic(err)
		}
		contractPairs = append(contractPairs, contractPair{contract, res})
	}

	if *flagGo {
		for _, pair := range contractPairs {
			contractTitle := strings.Title(pair.parsed.name)

			fmt.Fprint(outFile, "\n")
			fmt.Fprintf(outFile, "/* Contract %s\n", pair.parsed.name)
			fmt.Fprint(outFile, " *\n")

			width := pair.translated.opsWidth()
			f := fmt.Sprintf(" * %%-%d.%ds  # %%s\n", width, width)

			fmt.Fprintf(outFile, f, "", pair.parsed.initStackStr())
			for _, step := range pair.translated.steps {
				fmt.Fprintf(outFile, f, step.ops, step.stackStr())
			}
			fmt.Fprint(outFile, " */\n\n")

			fmt.Fprintf(outFile, "var %sContractBytes = []byte{", contractTitle)
			contractBytes, err := pair.translated.getBytes()
			if err != nil {
				panic(err)
			}
			for i, b := range contractBytes {
				if i > 0 {
					fmt.Fprint(outFile, ", ")
				}
				fmt.Fprintf(outFile, "%d", b)
			}
			fmt.Fprint(outFile, "}\n")
			h, err := pair.translated.getHash()
			if err != nil {
				panic(err)
			}
			fmt.Fprintf(outFile, "var %sContractHash = bc.ContractHash{", contractTitle)
			for i, b := range h {
				if i > 0 {
					fmt.Fprint(outFile, ", ")
				}
				fmt.Fprintf(outFile, "%d", b)
			}
			fmt.Fprint(outFile, "}\n\n")
			fmt.Fprintf(outFile, "func %sP2C(", contractTitle)
			emitParams(outFile, pair.parsed.params)
			fmt.Fprint(outFile, ") ([]byte, error) {\n")
			var inputsArg string
			if len(pair.parsed.params) > 0 {
				fmt.Fprintf(outFile, "\tinputs := make([][]byte, 0, %d)\n", len(pair.parsed.params))
				buildInputs(outFile, pair.parsed.params)
				inputsArg = "inputs"
			} else {
				inputsArg = "nil"
			}
			fmt.Fprintf(outFile, "\treturn vmutil.PayToContractHash(%sContractHash, %s)\n", contractTitle, inputsArg)
			fmt.Fprint(outFile, "}\n")
			for i, clause := range pair.parsed.clauses {
				fmt.Fprint(outFile, "\n")
				fmt.Fprintf(outFile, "func %sRedeem%s(", contractTitle, strings.Title(clause.name))
				emitParams(outFile, clause.params)
				fmt.Fprint(outFile, ") ([]byte, error) {\n")
				nItems := len(clause.params)
				needClauseSelector := len(pair.parsed.clauses) > 1
				if needClauseSelector {
					nItems++
				}
				if nItems > 0 {
					fmt.Fprintf(outFile, "\tinputs := make([][]byte, 0, %d)\n", nItems)
					if needClauseSelector {
						fmt.Fprintf(outFile, "\tinputs = append(inputs, vm.Int64Bytes(%d))\n", i+1)
					}
					buildInputs(outFile, clause.params)
					inputsArg = "inputs"
				} else {
					inputsArg = "nil"
				}
				fmt.Fprintf(outFile, "\treturn vmutil.RedeemP2C(%sContractBytes, %s)\n", contractTitle, inputsArg)
				fmt.Fprint(outFile, "}\n")
			}
		}
		return
	}

	// No "-go" on the command line.
	for i, pair := range contractPairs {
		if i > 0 {
			fmt.Printf("\n")
		}
		fmt.Printf("Contract \"%s\":\n", pair.parsed.name)

		width := pair.translated.opsWidth()
		f := fmt.Sprintf("%%-%d.%ds  # %%s\n", width, width)

		fmt.Printf(f, "", pair.parsed.initStackStr())
		for _, step := range pair.translated.steps {
			fmt.Printf(f, step.ops, step.stackStr())
		}

		bytes, err := pair.translated.getBytes()
		if err != nil {
			panic(err)
		}

		contractHex := hex.EncodeToString(bytes)

		fmt.Println("\nContract hex:")
		fmt.Println(contractHex)

		hash, err := pair.translated.getHash()
		if err != nil {
			panic(err)
		}

		fmt.Println("\nContracthash hex:")
		fmt.Println(hex.EncodeToString(hash[:]))

		pkscript := vmutil.PayToContractHash(hash, nil)

		// Passed nil for params above.  Add in placeholders for them
		// "manually."
		pkscriptSuffix := vmutil.NewBuilder()
		if len(pair.parsed.params) > 0 {
			pkscriptSuffix.AddInt64(int64(len(pair.parsed.params))).AddOp(vm.OP_ROLL)
		}
		pkscriptSuffix.AddRawBytes(pkscript) // DUP SHA3 <hash> EQUALVERIFY 0 CHECKPREDICATE

		fmt.Println("\nPkscript hex:")
		for n := len(pair.parsed.params) - 1; n >= 0; n-- {
			fmt.Printf("<%s>", pair.parsed.params[n].name)
		}
		fmt.Printf("%s\n", hex.EncodeToString(pkscriptSuffix.Program))

		for j, clause := range pair.parsed.clauses {
			fmt.Printf("\nRedeem %s.%s:\n", pair.parsed.name, clause.name)
			for n := len(clause.params) - 1; n >= 0; n-- {
				p := clause.params[n]
				fmt.Printf("<%s>", p.name)
			}
			var redeem []byte
			if len(pair.parsed.clauses) > 1 {
				redeem = vm.PushdataInt64(int64(j + 1))
			}
			redeem = append(redeem, vm.PushdataBytes(bytes)...)
			fmt.Printf("%s\n", hex.EncodeToString(redeem))
		}
	}
}

func emitParams(w io.Writer, params []typedName) {
	for i, param := range params {
		if i > 0 {
			fmt.Fprint(w, ", ")
		}
		var typ string
		switch param.typ {
		case unknownType, bytesType:
			typ = "[]byte"
		case numType:
			typ = "int64"
		case boolType:
			typ = "bool"
		}
		fmt.Fprintf(w, "%s %s", param.name, typ)
	}
}

func buildInputs(w io.Writer, params []typedName) {
	for _, param := range params {
		var toAppend string
		switch param.typ {
		case unknownType, bytesType:
			toAppend = param.name
		case numType:
			toAppend = fmt.Sprintf("vm.Int64Bytes(%s)", param.name)
		case boolType:
			toAppend = fmt.Sprintf("vm.BoolBytes(%s)", param.name)
		}
		fmt.Fprintf(w, "\tinputs = append(inputs, %s)\n", toAppend)
	}
}
