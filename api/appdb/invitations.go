package appdb

import (
	"chain/database/pg"
	"chain/errors"
	"crypto/rand"
	"database/sql"
	"encoding/hex"

	"golang.org/x/net/context"
)

// Invitation represents an invitation to an application. It is intended to be
// used with API responses.
type Invitation struct {
	ID      string `json:"id"`
	AppID   string `json:"project_id"`
	AppName string `json:"project_name"`
	Email   string `json:"email"`
	Role    string `json:"role"`

	// Returned by GetInvitation
	UserID string `json:"user_id,omitempty"`
}

// Errors returned from functions in this file.
var (
	ErrInviteUserDoesNotExist = errors.New("invited user does not have an account")
)

const inviteIDBytes = 16

// CreateInvitation generates an invitation for an email address to join the
// specified application under the specified role. The email address may
// represent an existing user account, or one that hasn't been created yet.
//
// The given email and role will be validated, and an error is returned if
// either is invalid.
func CreateInvitation(ctx context.Context, appID, email, role string) (*Invitation, error) {
	if err := validateEmail(email); err != nil {
		return nil, err
	}

	if err := validateRole(role); err != nil {
		return nil, err
	}

	// Ensure that the email address is not already part of the application.
	checkq := `
		SELECT 1 FROM users u
		JOIN members m ON u.id = m.user_id
		WHERE lower(u.email) = lower($1) AND m.application_id = $2
	`
	err := pg.FromContext(ctx).QueryRow(checkq, email, appID).Scan(new(int))
	if err == nil {
		return nil, ErrAlreadyMember
	}
	if err != sql.ErrNoRows {
		return nil, errors.Wrap(err, "check membership select query")
	}

	// Since IDs generated by next_chain_id() are relatively guessable, use an
	// ID that is not time-based.
	idRaw := make([]byte, inviteIDBytes)
	_, err = rand.Read(idRaw)
	if err != nil {
		return nil, errors.Wrap(err, "generate ID")
	}
	id := hex.EncodeToString(idRaw)

	insertq := `
		INSERT INTO invitations (id, application_id, email, role)
		VALUES ($1, $2, $3, $4)
	`
	_, err = pg.FromContext(ctx).Exec(insertq, id, appID, email, role)
	if err != nil {
		return nil, errors.Wrap(err, "insert invitation query")
	}

	var (
		nameq = `SELECT name FROM applications WHERE id = $1`
		name  string
	)
	err = pg.FromContext(ctx).QueryRow(nameq, appID).Scan(&name)
	if err != nil {
		return nil, errors.Wrap(err, "select app name query")
	}

	return &Invitation{
		ID:      id,
		AppID:   appID,
		AppName: name,
		Email:   email,
		Role:    role,
	}, nil
}

// GetInvitation retrieves an Invitation from the database. If a user account
// corresponding to the Invitation's Email field is present, then the UserID
// field will be populated.
//
// If a matching invitation cannot be found, an error will be returned with
// pg.ErrUserInputNotFound as the root.
func GetInvitation(ctx context.Context, invID string) (*Invitation, error) {
	var (
		q = `
			SELECT i.application_id, a.name, i.email, i.role, u.id
			FROM invitations i
			JOIN applications a ON i.application_id = a.id
			LEFT JOIN users u ON lower(i.email) = lower(u.email)
			WHERE i.id = $1
		`
		appID, appName, email, role string
		userID                      sql.NullString
	)
	err := pg.FromContext(ctx).QueryRow(q, invID).Scan(
		&appID,
		&appName,
		&email,
		&role,
		&userID,
	)
	if err == sql.ErrNoRows {
		return nil, errors.WithDetailf(pg.ErrUserInputNotFound, "invitation ID: %v", invID)
	}
	if err != nil {
		return nil, errors.Wrap(err, "select query")
	}

	return &Invitation{
		ID:      invID,
		AppID:   appID,
		AppName: appName,
		Email:   email,
		Role:    role,
		UserID:  userID.String,
	}, nil
}

// CreateUserFromInvitation creates a new user account, using a user-supplied
// password and the email address contained in the invitation. If the user
// account is successfully created, the user will be added to the application
// specified by the invitation, and the invitation will be deleted.
//
// This function should be used if there is no user account registered under the
// email address in the invitation. If such a user account already exists, use
// AddMemberFromInvitation instead.
//
// The new user account will be validated with the same rules as CreateUser, and
// any validation failure will cause an error to be returned. If the invitation
// cannot be found, an error will be returned with pg.ErrUserInputNotFound as
// the root.
//
// The caller should ensure that the context contains a database transaction, or
// the function will panic.
func CreateUserFromInvitation(ctx context.Context, invID, password string) (*User, error) {
	_ = pg.FromContext(ctx).(pg.Tx) // panics if not in a db transaction

	inv, err := GetInvitation(ctx, invID)
	if err != nil {
		return nil, errors.Wrap(err, "get invitation")
	}

	user, err := CreateUser(ctx, inv.Email, password)
	if err != nil {
		return nil, errors.Wrap(err, "create user")
	}

	err = AddMember(ctx, inv.AppID, user.ID, inv.Role)
	if err != nil {
		return nil, errors.Wrap(err, "add member")
	}

	err = deleteInvitation(ctx, inv.ID)
	if err != nil {
		return nil, errors.Wrap(err, "delete invitation")
	}

	return user, nil
}

// AddMemberFromInvitation will create a membership relation between a user and
// an application referenced by the given invitation. If the user is
// successfully added to the application, the invitation will be deleted.
//
// This function should be used only if there is pre-existing user account
// registered under the email address in the invitation. If such a user account
// does not exist, use CreateUserFromInvitation instead.
//
// The caller should ensure that the context contains a database transaction, or
// the function will panic.
func AddMemberFromInvitation(ctx context.Context, invID string) error {
	_ = pg.FromContext(ctx).(pg.Tx) // panics if not in a db transaction

	inv, err := GetInvitation(ctx, invID)
	if err != nil {
		return errors.Wrap(err, "get invitation")
	}

	if inv.UserID == "" {
		return ErrInviteUserDoesNotExist
	}

	err = AddMember(ctx, inv.AppID, inv.UserID, inv.Role)
	if err != nil {
		return errors.Wrap(err, "add member")
	}

	err = deleteInvitation(ctx, inv.ID)
	if err != nil {
		return errors.Wrap(err, "delete invitation")
	}

	return nil
}

func deleteInvitation(ctx context.Context, invID string) error {
	q := `DELETE FROM invitations WHERE id = $1`
	_, err := pg.FromContext(ctx).Exec(q, invID)
	if err != nil {
		return errors.Wrap(err, "delete query")
	}
	return nil
}
